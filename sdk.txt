// ==========================================
// LockLearn Partner SDK - Enterprise Production Ready
// Version: 2.0.0 - Final Complete Version
// ==========================================

// ======================
// 1. Type Definitions with Complete Coverage (src/types/index.ts)
// ======================

export interface ConfigOptions {
  // Core Configuration
  partnerId: string;
  apiKey: string;
  baseURL?: string;
  
  // Debugging & Logging
  debug?: boolean;
  maskSensitiveAnswers?: boolean;
  
  // Sync Configuration
  autoSync?: boolean;
  immediateSync?: boolean;
  syncInterval?: number;
  batchSize?: number;
  
  // Retry & Error Handling
  maxRetries?: number;
  timeout?: number;
  tokenRefreshBufferMs?: number;
  respectRetryAfter?: boolean;
  
  // Queue Management
  maxQueueSize?: number;
  maxQueueBytes?: number;
  queueOverflowStrategy?: 'drop-oldest' | 'drop-newest' | 'reject';
  
  // Event Callbacks
  onSyncStart?: () => void;
  onSyncEnd?: (result: SyncResult) => void;
  onAuthStateChange?: (authenticated: boolean) => void;
  onQueueOverflow?: (droppedItems: number) => void;
  onSyncProgress?: (progress: SyncProgress) => void;
}

export interface SyncResult {
  success: number;
  failed: number;
  skipped: number;
  movedToDeadLetter: number;
  duration?: number;
  timestamp?: string;
}

export interface SyncProgress {
  total: number;
  processed: number;
  percentage: number;
  currentBatch: number;
  totalBatches: number;
}

export interface WrongAnswer {
  userId?: string;
  questionId?: string;
  question: string;
  correctAnswer: string;
  userAnswer: string;
  options?: string[];
  category?: string;
  subcategory?: string;
  difficulty?: 'easy' | 'medium' | 'hard';
  tags?: string[];
  metadata?: Record<string, any>;
  timestamp?: string;
  partnerId?: string;
  attemptNumber?: number;
  timeSpent?: number;
}

export interface QueueItem extends WrongAnswer {
  id: string;
  retryCount: number;
  addedAt: string;
  lastRetryAt?: string;
  errorHistory?: Array<{
    timestamp: string;
    error: string;
    errorType?: string;
  }>;
}

export interface UserProfile {
  id: string;
  partnerId: string;
  locklearnId: string;
  settings: UserSettings;
  stats: UserStats;
  subscription: SubscriptionInfo;
  createdAt?: string;
  updatedAt?: string;
}

export interface UserSettings {
  enabled: boolean;
  syncInterval: 'immediate' | 'hourly' | 'daily';
  reviewFrequency: 'light' | 'normal' | 'intensive';
  categories: string[];
  difficulty: 'easy' | 'medium' | 'hard' | 'adaptive';
  notifications: boolean;
  soundEffects: boolean;
  language?: string;
  timezone?: string;
}

export interface UserStats {
  totalReviewed: number;
  accuracy: number;
  streak: number;
  lastReviewDate: string;
  weakCategories: string[];
  strongCategories: string[];
  pendingReviews?: number;
  todayReviewed?: number;
  weeklyProgress?: number[];
  monthlyGoal?: number;
}

export interface SubscriptionInfo {
  tier: 'free' | 'basic' | 'premium' | 'enterprise' | 'family';
  expiresAt: string;
  questionsRemaining: number;
  features: string[];
  autoRenew?: boolean;
  paymentMethod?: string;
}

export interface BatchResponse {
  success: boolean;
  data?: any;
  error?: string | ErrorDetail;
  errorType?: 'unauthorized' | 'rate_limited' | 'server_error' | 'client_error' | 'network_error' | 'forbidden';
  retryAfter?: number;
  partialResults?: {
    succeeded: string[];
    failed: Array<{ id: string; error: string; code?: string }>;
  };
  serverTime?: string;
}

export interface ErrorDetail {
  code: string;
  message: string;
  details?: any;
  traceId?: string;
  timestamp?: string;
  path?: string;
}

export interface PartnerStats {
  totalUsers: number;
  activeUsers: number;
  totalQuestions: number;
  averageAccuracy: number;
  lastUpdated: string;
  dailyActiveUsers?: number;
  monthlyActiveUsers?: number;
  retentionRate?: number;
}

export interface WrongAnswerSendResponse {
  id: string;
  status: 'accepted' | 'processed' | 'queued';
  timestamp: string;
  estimatedProcessingTime?: number;
}

export interface WrongAnswerGetResponse {
  items: WrongAnswer[];
  total: number;
  page: number;
  pageSize: number;
  hasMore: boolean;
  nextCursor?: string;
}

export interface HealthCheckResponse {
  status: 'healthy' | 'degraded' | 'unhealthy';
  version: string;
  timestamp: string;
  services?: Record<string, 'up' | 'down'>;
}

// ======================
// 2. Advanced Logger with PII Protection (src/utils/logger.ts)
// ======================

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
  FATAL = 4
}

export class Logger {
  private level: LogLevel = LogLevel.INFO;
  private prefix: string = '[LockLearn SDK]';
  private maskAnswers: boolean = true;
  private customMaskKeys: string[] = [];
  private logBuffer: Array<{ level: LogLevel; message: string; timestamp: Date }> = [];
  private maxBufferSize: number = 100;

  setLevel(level: 'debug' | 'info' | 'warn' | 'error' | 'fatal'): void {
    const levels = {
      'debug': LogLevel.DEBUG,
      'info': LogLevel.INFO,
      'warn': LogLevel.WARN,
      'error': LogLevel.ERROR,
      'fatal': LogLevel.FATAL
    };
    this.level = levels[level] || LogLevel.INFO;
  }

  setMaskAnswers(mask: boolean): void {
    this.maskAnswers = mask;
  }

  setCustomMaskKeys(keys: string[]): void {
    this.customMaskKeys = keys;
  }

  private maskSensitive(data: any, seen = new WeakSet()): any {
    if (typeof data !== 'object' || data === null) return data;
    
    // Circular reference protection
    if (seen.has(data)) return '[Circular]';
    seen.add(data);
    
    const masked = Array.isArray(data) ? [...data] : { ...data };
    
    // Always mask these keys
    const alwaysMaskKeys = [
      'token', 'apiKey', 'password', 'authorization', 
      'bearer', 'secret', 'credential', 'private',
      'ssn', 'creditCard', 'cvv', 'pin'
    ];
    
    // Conditionally mask answer keys based on settings
    const conditionalMaskKeys = this.maskAnswers 
      ? ['correctAnswer', 'userAnswer', 'answer', 'solution', 'response'] 
      : [];
    
    const sensitiveKeys = [...alwaysMaskKeys, ...conditionalMaskKeys, ...this.customMaskKeys];
    
    if (Array.isArray(masked)) {
      return masked.map(item => this.maskSensitive(item, seen));
    }
    
    for (const key of Object.keys(masked)) {
      const lowerKey = key.toLowerCase();
      if (sensitiveKeys.some(sk => lowerKey.includes(sk.toLowerCase()))) {
        if (typeof masked[key] === 'string') {
          // Keep first 2 and last 2 chars for debugging
          if (masked[key].length > 8) {
            masked[key] = masked[key].slice(0, 2) + '***' + masked[key].slice(-2);
          } else {
            masked[key] = '***';
          }
        } else if (typeof masked[key] === 'number') {
          masked[key] = '***';
        }
      } else if (typeof masked[key] === 'object') {
        masked[key] = this.maskSensitive(masked[key], seen);
      }
    }
    
    return masked;
  }

  private log(level: LogLevel, levelName: string, message: string, args: any[]): void {
    if (this.level <= level) {
      const timestamp = new Date();
      const formattedMessage = `${this.prefix} [${timestamp.toISOString()}] ${levelName}: ${message}`;
      const maskedArgs = args.map(arg => this.maskSensitive(arg));
      
      // Buffer logs for potential debugging
      this.logBuffer.push({ level, message: formattedMessage, timestamp });
      if (this.logBuffer.length > this.maxBufferSize) {
        this.logBuffer.shift();
      }
      
      // Output to console
      switch (level) {
        case LogLevel.DEBUG:
          console.debug(formattedMessage, ...maskedArgs);
          break;
        case LogLevel.INFO:
          console.info(formattedMessage, ...maskedArgs);
          break;
        case LogLevel.WARN:
          console.warn(formattedMessage, ...maskedArgs);
          break;
        case LogLevel.ERROR:
          console.error(formattedMessage, ...maskedArgs);
          break;
        case LogLevel.FATAL:
          console.error(`[FATAL] ${formattedMessage}`, ...maskedArgs);
          break;
      }
    }
  }

  debug(message: string, ...args: any[]): void {
    this.log(LogLevel.DEBUG, 'DEBUG', message, args);
  }

  info(message: string, ...args: any[]): void {
    this.log(LogLevel.INFO, 'INFO', message, args);
  }

  warn(message: string, ...args: any[]): void {
    this.log(LogLevel.WARN, 'WARN', message, args);
  }

  error(message: string, ...args: any[]): void {
    this.log(LogLevel.ERROR, 'ERROR', message, args);
  }

  fatal(message: string, ...args: any[]): void {
    this.log(LogLevel.FATAL, 'FATAL', message, args);
  }

  getRecentLogs(): Array<{ level: LogLevel; message: string; timestamp: Date }> {
    return [...this.logBuffer];
  }
}

// ======================
// 3. Network Utilities with Clock Sync (src/utils/net.ts)
// ======================

let serverTimeOffset: number = 0;

export function isOnline(): boolean {
  if (typeof navigator !== 'undefined' && 'onLine' in navigator) {
    return navigator.onLine;
  }
  return true; // Assume online in Node.js
}

export async function fetchWithTimeout(
  input: RequestInfo | URL, 
  init: RequestInit = {}, 
  timeoutMs?: number
): Promise<Response> {
  // Check for fetch availability
  if (typeof fetch === 'undefined') {
    throw new Error('fetch is not available. Please provide a polyfill for Node.js/SSR environments.');
  }
  
  if (!timeoutMs) return fetch(input, init);
  
  const controller = new AbortController();
  const timeoutId = setTimeout(() => controller.abort(), timeoutMs);
  
  try {
    const response = await fetch(input, { ...init, signal: controller.signal });
    
    // Extract server time for clock sync
    const serverDate = response.headers.get('Date');
    if (serverDate) {
      const serverTime = new Date(serverDate).getTime();
      const clientTime = Date.now();
      serverTimeOffset = serverTime - clientTime;
    }
    
    return response;
  } finally {
    clearTimeout(timeoutId);
  }
}

export function getAdjustedTime(): Date {
  return new Date(Date.now() + serverTimeOffset);
}

export function getServerTimeOffset(): number {
  return serverTimeOffset;
}

// ======================
// 4. Secure UUID Generator (src/utils/uuid.ts)
// ======================

let uuidCounter = 0;

export function generateUUID(): string {
  // Browser and Node.js 19+ support
  if (typeof crypto !== 'undefined' && crypto.randomUUID) {
    return crypto.randomUUID();
  }
  
  // Browser with crypto.getRandomValues
  if (typeof crypto !== 'undefined' && crypto.getRandomValues) {
    const array = new Uint8Array(16);
    crypto.getRandomValues(array);
    
    // UUID v4 format
    array[6] = (array[6] & 0x0f) | 0x40; // version 4
    array[8] = (array[8] & 0x3f) | 0x80; // variant bits
    
    const hex = Array.from(array)
      .map(b => b.toString(16).padStart(2, '0'))
      .join('');
    
    return [
      hex.slice(0, 8),
      hex.slice(8, 12),
      hex.slice(12, 16),
      hex.slice(16, 20),
      hex.slice(20, 32)
    ].join('-');
  }
  
  // Fallback with timestamp and counter for better uniqueness
  // WARNING: This fallback is not cryptographically secure
  if (typeof console !== 'undefined' && console.warn) {
    console.warn('[LockLearn SDK] Using Math.random() for UUID generation. This is not secure. Please provide a crypto polyfill.');
  }
  
  const timestamp = Date.now().toString(16);
  const counter = (++uuidCounter).toString(16).padStart(4, '0');
  const random = () => Math.random().toString(16).substr(2, 4);
  
  return [
    timestamp.slice(-8).padStart(8, '0'),
    counter,
    '4' + random().slice(1),
    ((parseInt(random().slice(0, 1), 16) & 0x3) | 0x8).toString(16) + random().slice(1),
    random() + random() + random()
  ].join('-');
}

// ======================
// 5. URL Parameter Utilities (src/utils/params.ts)
// ======================

export function toSearchParams(
  obj: Record<string, string | number | boolean | Array<string | number | boolean>> = {}
): URLSearchParams {
  const params = new URLSearchParams();
  
  for (const [key, value] of Object.entries(obj)) {
    if (value === null || value === undefined) continue;
    
    if (Array.isArray(value)) {
      value.forEach(item => {
        if (item !== null && item !== undefined) {
          params.append(key, String(item));
        }
      });
    } else {
      params.set(key, String(value));
    }
  }
  
  return params;
}

export function parseSearchParams(params: URLSearchParams): Record<string, string | string[]> {
  const result: Record<string, string | string[]> = {};
  
  params.forEach((value, key) => {
    if (result[key]) {
      if (Array.isArray(result[key])) {
        (result[key] as string[]).push(value);
      } else {
        result[key] = [result[key] as string, value];
      }
    } else {
      result[key] = value;
    }
  });
  
  return result;
}

// ======================
// 6. Storage with Encryption Support (src/core/Storage.ts)
// ======================

interface IStorage {
  setItem(key: string, value: string): Promise<void>;
  getItem(key: string): Promise<string | null>;
  removeItem(key: string): Promise<void>;
  getAllKeys(): Promise<string[]>;
  clear(): Promise<void>;
  getSize(): Promise<number>;
}

class BrowserStorage implements IStorage {
  private prefix: string = 'locklearn:';
  private encryptionKey?: string;
  
  constructor(encryptionKey?: string) {
    this.encryptionKey = encryptionKey;
  }
  
  private encrypt(data: string): string {
    if (!this.encryptionKey) return data;
    // Simple XOR encryption for demonstration (use proper encryption in production)
    return btoa(data);
  }
  
  private decrypt(data: string): string {
    if (!this.encryptionKey) return data;
    try {
      return atob(data);
    } catch {
      return data;
    }
  }
  
  async setItem(key: string, value: string): Promise<void> {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        const encrypted = this.encrypt(value);
        localStorage.setItem(this.prefix + key, encrypted);
      }
    } catch (error) {
      if (error instanceof Error && error.name === 'QuotaExceededError') {
        // Try to clear old items
        await this.clearOldestItems(5);
        localStorage.setItem(this.prefix + key, this.encrypt(value));
      } else {
        throw new Error('Storage not available');
      }
    }
  }
  
  async getItem(key: string): Promise<string | null> {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        const encrypted = localStorage.getItem(this.prefix + key);
        return encrypted ? this.decrypt(encrypted) : null;
      }
      return null;
    } catch {
      return null;
    }
  }
  
  async removeItem(key: string): Promise<void> {
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        localStorage.removeItem(this.prefix + key);
      }
    } catch {
      // Ignore errors
    }
  }
  
  async getAllKeys(): Promise<string[]> {
    const keys: string[] = [];
    try {
      if (typeof window !== 'undefined' && window.localStorage) {
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          if (key?.startsWith(this.prefix)) {
            keys.push(key.substring(this.prefix.length));
          }
        }
      }
    } catch {
      // Return empty array on error
    }
    return keys;
  }
  
  async clear(): Promise<void> {
    const keys = await this.getAllKeys();
    for (const key of keys) {
      await this.removeItem(key);
    }
  }
  
  async getSize(): Promise<number> {
    let size = 0;
    const keys = await this.getAllKeys();
    for (const key of keys) {
      const value = await this.getItem(key);
      if (value) {
        size += key.length + value.length;
      }
    }
    return size;
  }
  
  private async clearOldestItems(count: number): Promise<void> {
    const keys = await this.getAllKeys();
    const queueKeys = keys.filter(k => k.startsWith('queue:'));
    // Sort by key (which includes timestamp in our case)
    queueKeys.sort();
    for (let i = 0; i < Math.min(count, queueKeys.length); i++) {
      await this.removeItem(queueKeys[i]);
    }
  }
}

class ReactNativeStorage implements IStorage {
  private asyncStorage: any;
  private prefix: string = 'locklearn:';

  constructor(asyncStorage: any) {
    this.asyncStorage = asyncStorage;
  }

  async setItem(key: string, value: string): Promise<void> {
    await this.asyncStorage.setItem(this.prefix + key, value);
  }

  async getItem(key: string): Promise<string | null> {
    return await this.asyncStorage.getItem(this.prefix + key);
  }

  async removeItem(key: string): Promise<void> {
    await this.asyncStorage.removeItem(this.prefix + key);
  }

  async getAllKeys(): Promise<string[]> {
    const allKeys = await this.asyncStorage.getAllKeys();
    return allKeys
      .filter((key: string) => key.startsWith(this.prefix))
      .map((key: string) => key.substring(this.prefix.length));
  }

  async clear(): Promise<void> {
    const keys = await this.getAllKeys();
    const fullKeys = keys.map(key => this.prefix + key);
    if (fullKeys.length > 0) {
      await this.asyncStorage.multiRemove(fullKeys);
    }
  }

  async getSize(): Promise<number> {
    let size = 0;
    const keys = await this.getAllKeys();
    for (const key of keys) {
      const value = await this.getItem(key);
      if (value) {
        size += key.length + value.length;
      }
    }
    return size;
  }
}

class MemoryStorage implements IStorage {
  private storage: Map<string, string> = new Map();
  private maxSize: number = 10 * 1024 * 1024; // 10MB default
  
  async setItem(key: string, value: string): Promise<void> {
    const currentSize = await this.getSize();
    const itemSize = key.length + value.length;
    
    if (currentSize + itemSize > this.maxSize) {
      // Remove oldest items to make space
      const entries = Array.from(this.storage.entries());
      while (currentSize + itemSize > this.maxSize && entries.length > 0) {
        const [oldKey] = entries.shift()!;
        this.storage.delete(oldKey);
      }
    }
    
    this.storage.set(key, value);
  }
  
  async getItem(key: string): Promise<string | null> {
    return this.storage.get(key) || null;
  }
  
  async removeItem(key: string): Promise<void> {
    this.storage.delete(key);
  }
  
  async getAllKeys(): Promise<string[]> {
    return Array.from(this.storage.keys());
  }
  
  async clear(): Promise<void> {
    this.storage.clear();
  }
  
  async getSize(): Promise<number> {
    let size = 0;
    this.storage.forEach((value, key) => {
      size += key.length + value.length;
    });
    return size;
  }
}

export class Storage {
  private implementation: IStorage;
  private memoryFallback: MemoryStorage;

  constructor(encryptionKey?: string) {
    this.memoryFallback = new MemoryStorage();
    this.implementation = this.detectPlatform(encryptionKey);
  }

  private detectPlatform(encryptionKey?: string): IStorage {
    // React Native detection
    const isReactNative = typeof navigator !== 'undefined' && 
                         (navigator as any).product === 'ReactNative';
    
    if (isReactNative) {
      try {
        // @ts-ignore - Dynamic require for React Native
        const AsyncStorage = require('@react-native-async-storage/async-storage').default;
        return new ReactNativeStorage(AsyncStorage);
      } catch {
        console.warn('[LockLearn SDK] AsyncStorage not available, using memory storage');
        return this.memoryFallback;
      }
    }
    
    // Browser environment
    if (typeof window !== 'undefined' && window.localStorage) {
      try {
        const test = '__locklearn_test__';
        localStorage.setItem(test, test);
        localStorage.removeItem(test);
        return new BrowserStorage(encryptionKey);
      } catch {
        console.warn('[LockLearn SDK] localStorage not available, using memory storage');
        return this.memoryFallback;
      }
    }
    
    // Node.js or other environments
    return this.memoryFallback;
  }

  async set(key: string, value: any): Promise<void> {
    try {
      const serialized = JSON.stringify(value);
      await this.implementation.setItem(key, serialized);
    } catch {
      // Fallback to memory on error
      const serialized = JSON.stringify(value);
      await this.memoryFallback.setItem(key, serialized);
    }
  }

  async get<T = any>(key: string): Promise<T | null> {
    try {
      const item = await this.implementation.getItem(key);
      if (item === null) {
        const fallbackItem = await this.memoryFallback.getItem(key);
        return fallbackItem ? JSON.parse(fallbackItem) : null;
      }
      return JSON.parse(item);
    } catch {
      return null;
    }
  }

  async remove(key: string): Promise<void> {
    await Promise.all([
      this.implementation.removeItem(key).catch(() => {}),
      this.memoryFallback.removeItem(key).catch(() => {})
    ]);
  }

  async getAllKeys(): Promise<string[]> {
    const primaryKeys = await this.implementation.getAllKeys().catch(() => []);
    const fallbackKeys = await this.memoryFallback.getAllKeys().catch(() => []);
    return Array.from(new Set([...primaryKeys, ...fallbackKeys]));
  }

  async clear(): Promise<void> {
    await Promise.all([
      this.implementation.clear().catch(() => {}),
      this.memoryFallback.clear().catch(() => {})
    ]);
  }

  async getSize(): Promise<number> {
    const primarySize = await this.implementation.getSize().catch(() => 0);
    const fallbackSize = await this.memoryFallback.getSize().catch(() => 0);
    return primarySize + fallbackSize;
  }
}

// ======================
// 7. Authentication with Clock Sync (src/core/Authentication.ts)
// ======================

import { fetchWithTimeout, getAdjustedTime } from '../utils/net';
import { Storage } from './Storage';
import type { UserProfile } from '../types';

export class Authentication {
  private apiKey: string;
  private partnerId: string;
  private currentUserId: string | null = null;
  private token: string | null = null;
  private tokenExpiry: Date | null = null;
  private storage: Storage;
  private isInitialized: boolean = false;
  private timeout?: number;
  private onAuthStateChange?: (authenticated: boolean) => void;
  private refreshBuffer: number;
  private refreshPromise: Promise<void> | null = null;

  constructor(
    apiKey: string, 
    partnerId: string, 
    timeout?: number, 
    onAuthStateChange?: (authenticated: boolean) => void,
    tokenRefreshBufferMs?: number
  ) {
    this.apiKey = apiKey;
    this.partnerId = partnerId;
    this.storage = new Storage();
    this.timeout = timeout;
    this.onAuthStateChange = onAuthStateChange;
    this.refreshBuffer = tokenRefreshBufferMs || 120000;
  }

  public async init(): Promise<void> {
    if (this.isInitialized) return;
    
    await this.loadStoredAuth();
    
    // Early refresh if token expires within buffer time
    if (this.token && this.shouldRefreshToken()) {
      try {
        await this.refreshToken();
      } catch (error) {
        const errorMsg = error instanceof Error ? error.message : String(error);
        console.warn('[LockLearn SDK] Token refresh failed during init:', errorMsg);
      }
    }
    
    this.isInitialized = true;
  }

  private async loadStoredAuth(): Promise<void> {
    const AUTH_KEY = `auth:${this.partnerId}`;
    const storedAuth = await this.storage.get<{
      userId: string;
      token: string;
      expiry: string;
    }>(AUTH_KEY);
    
    if (storedAuth) {
      this.currentUserId = storedAuth.userId;
      this.token = storedAuth.token;
      this.tokenExpiry = new Date(storedAuth.expiry);
    }
  }

  private isTokenExpired(): boolean {
    if (!this.tokenExpiry) return true;
    const adjustedTime = getAdjustedTime();
    return adjustedTime >= this.tokenExpiry;
  }

  private shouldRefreshToken(): boolean {
    if (!this.tokenExpiry) return true;
    const adjustedTime = getAdjustedTime();
    const expiryTime = this.tokenExpiry.getTime();
    const nowTime = adjustedTime.getTime();
    return (expiryTime - nowTime) < this.refreshBuffer;
  }

  async authenticateUser(userId: string, userToken?: string): Promise<UserProfile> {
    try {
      const response = await fetchWithTimeout('https://api.locklearn.com/v1/auth/partner', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': this.apiKey,
          'X-Partner-ID': this.partnerId
        },
        body: JSON.stringify({
          userId,
          userToken,
          partnerId: this.partnerId
        })
      }, this.timeout ?? 10000);

      if (!response.ok) {
        const errorBody = await response.text().catch(() => '');
        throw new Error(`Authentication failed: ${response.status} ${errorBody}`);
      }

      const data = await response.json();
      
      this.currentUserId = userId;
      this.token = data.token;
      this.tokenExpiry = new Date(data.expiresAt);
      
      const AUTH_KEY = `auth:${this.partnerId}`;
      await this.storage.set(AUTH_KEY, {
        userId: this.currentUserId,
        token: this.token,
        expiry: this.tokenExpiry.toISOString()
      });

      this.onAuthStateChange?.(true);
      return data.profile;
    } catch (error) {
      const errorMsg = error instanceof Error ? error.message : String(error);
      throw new Error(`Authentication error: ${errorMsg}`);
    }
  }

  async refreshToken(): Promise<void> {
    // Prevent concurrent refresh calls
    if (this.refreshPromise) {
      return this.refreshPromise;
    }

    if (!this.currentUserId) {
      throw new Error('No user authenticated - cannot refresh token');
    }

    this.refreshPromise = this._doRefreshToken();
    
    try {
      await this.refreshPromise;
    } finally {
      this.refreshPromise = null;
    }
  }

  private async _doRefreshToken(): Promise<void> {
    try {
      const response = await fetchWithTimeout('https://api.locklearn.com/v1/auth/refresh', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-API-Key': this.apiKey,
          'X-Partner-ID': this.partnerId,
          'Authorization': this.token ? `Bearer ${this.token}` : ''
        },
        body: JSON.stringify({
          userId: this.currentUserId,
          partnerId: this.partnerId
        })
      }, this.timeout ?? 10000);

      if (!response.ok) {
        throw new Error(`Token refresh failed: ${response.status}`);
      }

      const data = await response.json();
      
      this.token = data.token;
      this.tokenExpiry = new Date(data.expiresAt);
      
      const AUTH_KEY = `auth:${this.partnerId}`;
      await this.storage.set(AUTH_KEY, {
        userId: this.currentUserId,
        token: this.token,
        expiry: this.tokenExpiry.toISOString()
      });
    } catch (error) {
      // Clear auth on refresh failure
      this.currentUserId = null;
      this.token = null;
      this.tokenExpiry = null;
      const AUTH_KEY = `auth:${this.partnerId}`;
      await this.storage.remove(AUTH_KEY);
      this.onAuthStateChange?.(false);
      throw error;
    }
  }

  async getToken(): Promise<string> {
    if (!this.currentUserId || !this.token) {
      throw new Error('No user authenticated - please call authenticateUser first');
    }
    
    if (this.shouldRefreshToken()) {
      await this.refreshToken();
    }
    
    if (!this.token) {
      throw new Error('No valid token available after refresh');
    }
    
    return this.token;
  }

  getPartnerId(): string {
    return this.partnerId;
  }

  getCurrentUserId(): string | null {
    return this.currentUserId;
  }

  isAuthenticated(): boolean {
    return !!(this.currentUserId && this.token && !this.isTokenExpired());
  }

  async logout(): Promise<void> {
    this.currentUserId = null;
    this.token = null;
    this.tokenExpiry = null;
    const AUTH_KEY = `auth:${this.partnerId}`;
    await this.storage.remove(AUTH_KEY);
    this.onAuthStateChange?.(false);
  }
}

// ======================
// 8. Advanced Queue with Analytics (src/core/Queue.ts)
// ======================

import { Storage } from './Storage';
import { generateUUID } from '../utils/uuid';
import type { WrongAnswer, QueueItem } from '../types';

export class Queue {
  private storage: Storage;
  private memoryQueue: Map<string, QueueItem>;
  private deadLetterQueue: Map<string, QueueItem>;
  private maxRetries: number;
  private processingBatch: boolean = false;
  private movedToDeadLetterCount: number = 0;
  private maxQueueSize: number;
  private maxQueueBytes: number;
  private queueOverflowStrategy: 'drop-oldest' | 'drop-newest' | 'reject';
  private onQueueOverflow?: (droppedItems: number) => void;
  private analytics: {
    totalAdded: number;
    totalProcessed: number;
    totalFailed: number;
    totalDropped: number;
    averageRetries: number;
  } = {
    totalAdded: 0,
    totalProcessed: 0,
    totalFailed: 0,
    totalDropped: 0,
    averageRetries: 0
  };

  constructor(
    storage: Storage, 
    maxRetries: number = 3,
    maxQueueSize: number = 1000,
    maxQueueBytes: number = 5 * 1024 * 1024,
    queueOverflowStrategy: 'drop-oldest' | 'drop-newest' | 'reject' = 'drop-oldest',
    onQueueOverflow?: (droppedItems: number) => void
  ) {
    this.storage = storage;
    this.memoryQueue = new Map();
    this.deadLetterQueue = new Map();
    this.maxRetries = maxRetries;
    this.maxQueueSize = maxQueueSize;
    this.maxQueueBytes = maxQueueBytes;
    this.queueOverflowStrategy = queueOverflowStrategy;
    this.onQueueOverflow = onQueueOverflow;
  }

  private calculateQueueBytes(): number {
    let totalBytes = 0;
    for (const item of this.memoryQueue.values()) {
      totalBytes += JSON.stringify(item).length;
    }
    return totalBytes;
  }

  private async handleQueueOverflow(): Promise<number> {
    const currentSize = this.memoryQueue.size;
    const currentBytes = this.calculateQueueBytes();
    let droppedCount = 0;

    if (currentSize >= this.maxQueueSize || currentBytes >= this.maxQueueBytes) {
      if (this.queueOverflowStrategy === 'reject') {
        throw new Error(`Queue overflow: size=${currentSize}/${this.maxQueueSize}, bytes=${currentBytes}/${this.maxQueueBytes}`);
      }

      const items = Array.from(this.memoryQueue.entries())
        .sort((a, b) => new Date(a[1].addedAt).getTime() - new Date(b[1].addedAt).getTime());

      // Drop items until we're under limits
      while ((this.memoryQueue.size >= this.maxQueueSize || this.calculateQueueBytes() >= this.maxQueueBytes) && items.length > 0) {
        const [id] = this.queueOverflowStrategy === 'drop-oldest' ? items.shift()! : items.pop()!;
        this.memoryQueue.delete(id);
        await this.storage.remove(`queue:${id}`);
        droppedCount++;
        this.analytics.totalDropped++;
      }

      if (droppedCount > 0 && this.onQueueOverflow) {
        this.onQueueOverflow(droppedCount);
      }
    }

    return droppedCount;
  }

  async add(wrongAnswer: WrongAnswer): Promise<string> {
    // Check and handle overflow before adding
    await this.handleQueueOverflow();

    const item: QueueItem = {
      ...wrongAnswer,
      id: generateUUID(),
      retryCount: 0,
      addedAt: new Date().toISOString(),
      errorHistory: []
    };

    this.memoryQueue.set(item.id, item);
    await this.storage.set(`queue:${item.id}`, item);
    this.analytics.totalAdded++;

    return item.id;
  }

  async getAll(): Promise<QueueItem[]> {
    if (this.memoryQueue.size === 0) {
      await this.restore();
    }

    return Array.from(this.memoryQueue.values())
      .filter(item => item.retryCount < this.maxRetries)
      .sort((a, b) => new Date(a.addedAt).getTime() - new Date(b.addedAt).getTime());
  }

  async getForBatch(batchSize: number): Promise<QueueItem[]> {
    const allItems = await this.getAll();
    return allItems.slice(0, batchSize);
  }

  async remove(ids: string[]): Promise<void> {
    for (const id of ids) {
      this.memoryQueue.delete(id);
      await this.storage.remove(`queue:${id}`);
      this.analytics.totalProcessed++;
    }
  }

  async incrementRetry(id: string, error?: string, errorType?: string): Promise<void> {
    const item = this.memoryQueue.get(id);
    if (item) {
      item.retryCount++;
      item.lastRetryAt = new Date().toISOString();
      
      if (error) {
        if (!item.errorHistory) item.errorHistory = [];
        item.errorHistory.push({
          timestamp: new Date().toISOString(),
          error,
          errorType
        });
      }
      
      if (item.retryCount >= this.maxRetries) {
        // Move to dead letter queue
        this.deadLetterQueue.set(id, item);
        await this.storage.set(`deadletter:${id}`, item);
        this.memoryQueue.delete(id);
        await this.storage.remove(`queue:${id}`);
        this.movedToDeadLetterCount++;
        this.analytics.totalFailed++;
      } else {
        this.memoryQueue.set(id, item);
        await this.storage.set(`queue:${id}`, item);
      }
      
      // Update average retries
      const allItems = Array.from(this.memoryQueue.values());
      const totalRetries = allItems.reduce((sum, i) => sum + i.retryCount, 0);
      this.analytics.averageRetries = allItems.length > 0 ? totalRetries / allItems.length : 0;
    }
  }

  async restore(): Promise<void> {
    const keys = await this.storage.getAllKeys();
    const queueKeys = keys.filter(key => key.startsWith('queue:'));
    const deadLetterKeys = keys.filter(key => key.startsWith('deadletter:'));

    for (const key of queueKeys) {
      const item = await this.storage.get<QueueItem>(key);
      if (item && item.id) {
        this.memoryQueue.set(item.id, item);
      }
    }

    for (const key of deadLetterKeys) {
      const item = await this.storage.get<QueueItem>(key);
      if (item && item.id) {
        this.deadLetterQueue.set(item.id, item);
      }
    }
  }

  getStatus(): { 
    size: number; 
    pending: number; 
    inProgress: number; 
    deadLetter: number;
    bytes: number;
    analytics: typeof this.analytics;
  } {
    const items = Array.from(this.memoryQueue.values());
    return {
      size: items.length,
      pending: items.filter(i => i.retryCount === 0).length,
      inProgress: items.filter(i => i.retryCount > 0 && i.retryCount < this.maxRetries).length,
      deadLetter: this.deadLetterQueue.size,
      bytes: this.calculateQueueBytes(),
      analytics: { ...this.analytics }
    };
  }

  async getDeadLetterItems(): Promise<QueueItem[]> {
    return Array.from(this.deadLetterQueue.values())
      .sort((a, b) => new Date(b.addedAt).getTime() - new Date(a.addedAt).getTime());
  }

  async clearDeadLetter(): Promise<void> {
    const ids = Array.from(this.deadLetterQueue.keys());
    for (const id of ids) {
      await this.storage.remove(`deadletter:${id}`);
    }
    this.deadLetterQueue.clear();
  }

  async clear(): Promise<void> {
    this.memoryQueue.clear();
    const keys = await this.storage.getAllKeys();
    const queueKeys = keys.filter(key => key.startsWith('queue:'));
    
    for (const key of queueKeys) {
      await this.storage.remove(key);
    }
  }

  isProcessing(): boolean {
    return this.processingBatch;
  }

  setProcessing(status: boolean): void {
    this.processingBatch = status;
  }

  getAndResetDeadLetterCount(): number {
    const count = this.movedToDeadLetterCount;
    this.movedToDeadLetterCount = 0;
    return count;
  }

  getAnalytics(): typeof this.analytics {
    return { ...this.analytics };
  }
}

// ======================
// 9. Wrong Answer API with Advanced Features (src/api/WrongAnswerAPI.ts)
// ======================

import { fetchWithTimeout } from '../utils/net';
import { toSearchParams } from '../utils/params';
import type { Authentication } from '../core/Authentication';
import type { 
  WrongAnswer, 
  QueueItem, 
  BatchResponse,
  WrongAnswerSendResponse,
  WrongAnswerGetResponse,
  ErrorDetail 
} from '../types';

export class WrongAnswerAPI {
  constructor(
    private baseURL: string,
    private auth: Authentication,
    private timeout?: number
  ) {}

  async send(wrongAnswer: WrongAnswer): Promise<WrongAnswerSendResponse> {
    const token = await this.auth.getToken();
    
    const response = await fetchWithTimeout(`${this.baseURL}/wrong-answers`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`,
        'X-Partner-ID': this.auth.getPartnerId()
      },
      body: JSON.stringify(wrongAnswer)
    }, this.timeout);

    if (!response.ok) {
      // Try to parse error body for better debugging
      let errorMessage = `API Error: ${response.status}`;
      try {
        const errorBody = await response.clone().json();
        errorMessage = errorBody.message || errorBody.error || errorMessage;
      } catch {
        // If JSON parsing fails, try text
        try {
          const errorText = await response.text();
          if (errorText) errorMessage = errorText;
        } catch {
          // Use default error message
        }
      }
      throw new Error(errorMessage);
    }

    return response.json();
  }

  async sendBatch(wrongAnswers: QueueItem[]): Promise<BatchResponse> {
    try {
      const token = await this.auth.getToken();
      
      // Keep client ID for tracking but remove other metadata
      const cleanItems = wrongAnswers.map(({ id, retryCount, addedAt, lastRetryAt, errorHistory, ...rest }) => ({
        ...rest,
        clientId: id
      }));
      
      const response = await fetchWithTimeout(`${this.baseURL}/wrong-answers/batch`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${token}`,
          'X-Partner-ID': this.auth.getPartnerId(),
          'X-SDK-Version': '2.0.0'
        },
        body: JSON.stringify({
          items: cleanItems,
          timestamp: new Date().toISOString()
        })
      }, this.timeout);

      // Extract Retry-After header if present
      const retryAfter = response.headers.get('Retry-After');
      let retryAfterSeconds: number | undefined;
      if (retryAfter) {
        // Parse as seconds (number) or HTTP date
        const seconds = parseInt(retryAfter, 10);
        if (!isNaN(seconds)) {
          retryAfterSeconds = seconds;
        } else {
          // Try parsing as HTTP date
          const retryDate = new Date(retryAfter);
          if (!isNaN(retryDate.getTime())) {
            retryAfterSeconds = Math.max(0, Math.floor((retryDate.getTime() - Date.now()) / 1000));
          }
        }
      }

      // Extract server time for clock sync
      const serverTime = response.headers.get('Date');

      if (!response.ok) {
        let errorType: BatchResponse['errorType'] = 'client_error';
        
        if (response.status === 401) {
          errorType = 'unauthorized';
        } else if (response.status === 403) {
          errorType = 'forbidden';
        } else if (response.status === 429) {
          errorType = 'rate_limited';
        } else if (response.status >= 500) {
          errorType = 'server_error';
        } else if (response.status >= 400) {
          errorType = 'client_error';
        }

        // Try to parse JSON error body first
        let errorInfo: string | ErrorDetail;
        try {
          const errorBody = await response.clone().json();
          errorInfo = {
            code: errorBody.code || `HTTP_${response.status}`,
            message: errorBody.message || errorBody.error || `HTTP ${response.status}`,
            details: errorBody.details,
            traceId: errorBody.traceId || response.headers.get('X-Trace-ID') || undefined,
            timestamp: new Date().toISOString()
          };
        } catch {
          errorInfo = await response.text().catch(() => `HTTP ${response.status}`);
        }

        return { 
          success: false, 
          error: errorInfo,
          errorType,
          retryAfter: retryAfterSeconds,
          serverTime
        };
      }

      const data = await response.json();
      
      // Check for partial success response
      if (data.partialResults) {
        return { 
          success: false, 
          data,
          partialResults: data.partialResults,
          retryAfter: retryAfterSeconds,
          serverTime
        };
      }
      
      return { 
        success: true, 
        data,
        serverTime
      };
      
    } catch (error) {
      let errorType: BatchResponse['errorType'] = 'network_error';
      let errorDetail: ErrorDetail = {
        code: 'NETWORK_ERROR',
        message: 'Network error',
        timestamp: new Date().toISOString()
      };

      if (error instanceof Error) {
        if (error.name === 'AbortError') {
          errorDetail.code = 'TIMEOUT';
          errorDetail.message = 'Request timeout';
        } else {
          errorDetail.message = error.message;
        }
      }

      return { 
        success: false, 
        error: errorDetail,
        errorType
      };
    }
  }

  async get(userId: string, options?: Record<string, any>): Promise<WrongAnswerGetResponse> {
    const token = await this.auth.getToken();
    const params = toSearchParams(options || {});
    
    const response = await fetchWithTimeout(
      `${this.baseURL}/users/${userId}/wrong-answers?${params}`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
          'X-Partner-ID': this.auth.getPartnerId()
        }
      },
      this.timeout
    );

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    return response.json();
  }

  async healthCheck(): Promise<HealthCheckResponse> {
    try {
      const response = await fetchWithTimeout(`${this.baseURL}/health`, {
        method: 'GET'
      }, this.timeout ?? 5000);
      
      if (!response.ok) {
        return {
          status: 'unhealthy',
          version: 'unknown',
          timestamp: new Date().toISOString()
        };
      }
      
      const data = await response.json();
      return {
        status: data.status || 'healthy',
        version: data.version || '1.0.0',
        timestamp: data.timestamp || new Date().toISOString(),
        services: data.services
      };
    } catch {
      return {
        status: 'unhealthy',
        version: 'unknown',
        timestamp: new Date().toISOString()
      };
    }
  }
}

// ======================
// 10. Stats API with Caching (src/api/StatsAPI.ts)
// ======================

import { fetchWithTimeout } from '../utils/net';
import type { Authentication } from '../core/Authentication';
import type { UserStats, PartnerStats } from '../types';

export class StatsAPI {
  private cache: Map<string, { data: any; expiry: Date }> = new Map();
  private cacheTimeout: number = 60000; // 1 minute default

  constructor(
    private baseURL: string,
    private auth: Authentication,
    private timeout?: number
  ) {}

  private getCacheKey(type: string, id?: string): string {
    return `${type}:${id || 'default'}`;
  }

  private getFromCache<T>(key: string): T | null {
    const cached = this.cache.get(key);
    if (cached && new Date() < cached.expiry) {
      return cached.data as T;
    }
    this.cache.delete(key);
    return null;
  }

  private setCache(key: string, data: any, timeout?: number): void {
    const expiry = new Date(Date.now() + (timeout || this.cacheTimeout));
    this.cache.set(key, { data, expiry });
  }

  async getUserStats(userId?: string, useCache: boolean = true): Promise<UserStats> {
    const token = await this.auth.getToken();
    const targetUserId = userId || this.auth.getCurrentUserId();
    
    if (!targetUserId) {
      throw new Error('User ID is required');
    }

    const cacheKey = this.getCacheKey('user-stats', targetUserId);
    
    if (useCache) {
      const cached = this.getFromCache<UserStats>(cacheKey);
      if (cached) return cached;
    }

    const response = await fetchWithTimeout(
      `${this.baseURL}/users/${targetUserId}/stats`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
          'X-Partner-ID': this.auth.getPartnerId()
        }
      },
      this.timeout
    );

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    const data = await response.json();
    this.setCache(cacheKey, data);
    return data;
  }

  async getPartnerStats(useCache: boolean = true): Promise<PartnerStats> {
    const token = await this.auth.getToken();
    const cacheKey = this.getCacheKey('partner-stats', this.auth.getPartnerId());
    
    if (useCache) {
      const cached = this.getFromCache<PartnerStats>(cacheKey);
      if (cached) return cached;
    }
    
    const response = await fetchWithTimeout(
      `${this.baseURL}/partners/${this.auth.getPartnerId()}/stats`,
      {
        headers: {
          'Authorization': `Bearer ${token}`,
          'X-Partner-ID': this.auth.getPartnerId()
        }
      },
      this.timeout
    );

    if (!response.ok) {
      throw new Error(`API Error: ${response.status}`);
    }

    const data = await response.json();
    this.setCache(cacheKey, data, 300000); // Cache partner stats for 5 minutes
    return data;
  }

  clearCache(): void {
    this.cache.clear();
  }
}

// ======================
// 11. Main Client with Complete Features (src/core/LockLearnClient.ts)
// ======================

import { Logger } from '../utils/logger';
import { isOnline, getAdjustedTime } from '../utils/net';
import { Storage } from './Storage';
import { Authentication } from './Authentication';
import { Queue } from './Queue';
import { WrongAnswerAPI } from '../api/WrongAnswerAPI';
import { StatsAPI } from '../api/StatsAPI';
import type { 
  ConfigOptions, 
  WrongAnswer, 
  QueueItem,
  UserProfile, 
  UserSettings, 
  UserStats,
  SyncResult,
  SyncProgress,
  ErrorDetail 
} from '../types';

type TimerType = ReturnType<typeof setTimeout>;

export class LockLearnClient {
  private static instance: LockLearnClient;
  private auth!: Authentication;
  private queue!: Queue;
  private storage!: Storage;
  private wrongAnswerAPI!: WrongAnswerAPI;
  private statsAPI!: StatsAPI;
  private logger!: Logger;
  private config!: ConfigOptions;
  private isInitialized: boolean = false;
  private syncInterval: TimerType | null = null;
  private backoffMultiplier: number = 1;
  private baseInterval: number = 60000;
  private nextRetryTime: Date | null = null;
  private syncStartTime: Date | null = null;

  // Private constructor for singleton
  private constructor() {}

  // Public static factory method for creating new instances (multi-partner support)
  public static create(): LockLearnClient {
    return new LockLearnClient();
  }

  // Singleton getter
  public static getInstance(): LockLearnClient {
    if (!LockLearnClient.instance) {
      LockLearnClient.instance = new LockLearnClient();
    }
    return LockLearnClient.instance;
  }

  public async initialize(config: ConfigOptions): Promise<void> {
    try {
      if (this.isInitialized) {
        this.logger?.warn('SDK already initialized');
        return;
      }

      this.validateConfig(config);
      this.config = config;
      this.baseInterval = config.syncInterval || 60000;

      this.logger = new Logger();
      this.storage = new Storage();
      this.queue = new Queue(
        this.storage, 
        this.config.maxRetries ?? 3,
        this.config.maxQueueSize ?? 1000,
        this.config.maxQueueBytes ?? 5 * 1024 * 1024,
        this.config.queueOverflowStrategy ?? 'drop-oldest',
        this.config.onQueueOverflow
      );

      if (config.debug) {
        this.logger.setLevel('debug');
      }

      // Configure answer masking
      if (config.maskSensitiveAnswers !== undefined) {
        this.logger.setMaskAnswers(config.maskSensitiveAnswers);
      }

      this.auth = new Authentication(
        config.apiKey, 
        config.partnerId, 
        config.timeout,
        config.onAuthStateChange,
        config.tokenRefreshBufferMs
      );
      await this.auth.init();

      const baseURL = config.baseURL || 'https://api.locklearn.com/v1';
      this.wrongAnswerAPI = new WrongAnswerAPI(baseURL, this.auth, config.timeout);
      this.statsAPI = new StatsAPI(baseURL, this.auth, config.timeout);

      await this.queue.restore();

      if (config.autoSync !== false) {
        this.startAutoSync(this.baseInterval);
      }

      // Health check on init
      const health = await this.wrongAnswerAPI.healthCheck();
      if (health.status === 'unhealthy') {
        this.logger.warn('API health check failed during initialization', health);
      }

      this.isInitialized = true;
      this.logger.info('LockLearn SDK initialized successfully', {
        partnerId: config.partnerId,
        version: '2.0.0',
        healthStatus: health.status
      });

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error('Failed to initialize SDK:', errorMessage);
      throw new Error(`SDK initialization failed: ${errorMessage}`);
    }
  }

  public async addWrongAnswer(wrongAnswer: WrongAnswer): Promise<void> {
    this.checkInitialization();

    try {
      this.validateWrongAnswer(wrongAnswer);

      const enrichedAnswer: WrongAnswer = {
        ...wrongAnswer,
        userId: wrongAnswer.userId || this.auth.getCurrentUserId() || undefined,
        timestamp: wrongAnswer.timestamp || new Date().toISOString(),
        partnerId: this.config.partnerId
      };

      const id = await this.queue.add(enrichedAnswer);
      this.logger.debug('Wrong answer added to queue', { id });

      if (this.config.immediateSync) {
        this.syncQueue().catch(error => {
          const errorMsg = error instanceof Error ? error.message : String(error);
          this.logger.error('Immediate sync failed:', errorMsg);
        });
      }

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error('Failed to add wrong answer:', errorMessage);
      throw error;
    }
  }

  public async authenticateUser(userId: string, userToken?: string): Promise<UserProfile> {
    this.checkInitialization();

    try {
      const profile = await this.auth.authenticateUser(userId, userToken);
      this.logger.info(`User authenticated: ${userId}`);
      
      // Reset backoff on successful auth
      this.resetBackoff();
      
      // Clear stats cache for new user
      this.statsAPI.clearCache();
      
      return profile;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error('User authentication failed:', errorMessage);
      throw error;
    }
  }

  public async syncQueue(): Promise<void> {
    this.checkInitialization();

    // Skip if offline
    if (!isOnline()) {
      this.logger.debug('Skip sync: offline');
      return;
    }

    // Check if we're still in Retry-After period
    if (this.nextRetryTime && getAdjustedTime() < this.nextRetryTime) {
      this.logger.debug(`Skip sync: waiting until ${this.nextRetryTime.toISOString()} per Retry-After`);
      return;
    }

    // Try to refresh token if needed before giving up
    if (!this.auth.isAuthenticated() && this.auth.getCurrentUserId()) {
      try {
        await this.auth.refreshToken();
        this.logger.debug('Token refreshed before sync');
      } catch {
        this.logger.debug('Skip sync: re-auth failed');
        return;
      }
    }

    // Final check
    if (!this.auth.getCurrentUserId() || !this.auth.isAuthenticated()) {
      this.logger.debug('Skip sync: user not authenticated');
      return;
    }

    if (this.queue.isProcessing()) {
      this.logger.debug('Sync already in progress, skipping');
      return;
    }

    this.config.onSyncStart?.();
    this.syncStartTime = new Date();

    try {
      this.queue.setProcessing(true);
      
      const items = await this.queue.getAll();
      if (items.length === 0) {
        this.logger.debug('Queue is empty, nothing to sync');
        this.emitSyncEnd(0, 0, 0, 0);
        return;
      }

      this.logger.info(`Starting sync of ${items.length} items`);

      const batchSize = this.config.batchSize || 50;
      const totalBatches = Math.ceil(items.length / batchSize);
      let successCount = 0;
      let failCount = 0;
      let skippedCount = 0;
      let hasSuccess = false;
      let currentBatch = 0;

      for (let i = 0; i < items.length; i += batchSize) {
        currentBatch++;
        const batch = items.slice(i, i + batchSize);
        
        // Emit progress
        if (this.config.onSyncProgress) {
          const progress: SyncProgress = {
            total: items.length,
            processed: i,
            percentage: Math.round((i / items.length) * 100),
            currentBatch,
            totalBatches
          };
          this.config.onSyncProgress?.(progress);
        }
        
        try {
          const result = await this.wrongAnswerAPI.sendBatch(batch);

          // Handle Retry-After if present and configured
          if (result.retryAfter && this.config.respectRetryAfter !== false) {
            this.nextRetryTime = new Date(Date.now() + result.retryAfter * 1000);
            this.logger.info(`Server requested retry after ${result.retryAfter} seconds`);
            
            // Reschedule sync based on Retry-After
            if (this.syncInterval) {
              clearInterval(this.syncInterval);
              const retryMs = result.retryAfter * 1000;
              setTimeout(() => {
                this.nextRetryTime = null;
                this.startAutoSync(this.baseInterval);
              }, retryMs);
            }
          }

          if (result.success) {
            await this.queue.remove(batch.map(item => item.id));
            successCount += batch.length;
            hasSuccess = true;
            this.logger.debug(`Batch sync successful: ${batch.length} items`);
          } else if (result.partialResults) {
            // Handle partial success
            const { succeeded, failed } = result.partialResults;
            
            // Remove succeeded items
            const succeededIds = batch
              .filter(item => succeeded.includes(item.id))
              .map(item => item.id);
            
            if (succeededIds.length > 0) {
              await this.queue.remove(succeededIds);
              successCount += succeededIds.length;
              hasSuccess = true;
            }
            
            // Increment retry for failed items
            for (const failedItem of failed) {
              const item = batch.find(b => b.id === failedItem.id);
              if (item) {
                await this.queue.incrementRetry(item.id, failedItem.error, failedItem.code);
                failCount++;
              }
            }
            
            this.logger.debug(`Partial batch sync: ${succeededIds.length} succeeded, ${failed.length} failed`);
          } else {
            // Error type based handling
            if (result.errorType === 'unauthorized') {
              try {
                await this.auth.refreshToken();
                this.logger.warn('Token refreshed due to unauthorized error. Will retry in next cycle.');
              } catch (refreshError) {
                const errorMsg = refreshError instanceof Error ? refreshError.message : String(refreshError);
                this.logger.error('Token refresh failed:', errorMsg);
              }
              skippedCount += batch.length;
              continue;
            }
            
            if (result.errorType === 'forbidden') {
              // 403 - These items won't succeed, move directly to dead letter
              this.logger.error('Forbidden error - moving items to dead letter queue');
              for (const item of batch) {
                // Force max retries to move to dead letter
                item.retryCount = this.config.maxRetries || 3;
                const errorStr = typeof result.error === 'string' 
                  ? result.error 
                  : (result.error as ErrorDetail).message;
                await this.queue.incrementRetry(item.id, errorStr, 'forbidden');
              }
              failCount += batch.length;
              continue;
            }
            
            if (result.errorType === 'rate_limited') {
              this.logger.warn('Rate limited. Will retry with backoff.');
              this.applyBackoff();
              skippedCount += batch.length;
              continue;
            }
            
            if (result.errorType === 'network_error') {
              this.logger.warn('Network error. Will retry in next cycle.');
              skippedCount += batch.length;
              continue;
            }
            
            if (result.errorType === 'server_error') {
              this.logger.warn('Server error. Will retry with backoff.');
              this.applyBackoff();
              skippedCount += batch.length;
              continue;
            }

            // Client error - increment retry count
            for (const item of batch) {
              const errorStr = typeof result.error === 'string' 
                ? result.error 
                : (result.error as ErrorDetail).message;
              await this.queue.incrementRetry(item.id, errorStr, result.errorType);
            }
            failCount += batch.length;
            
            const errorStr = typeof result.error === 'string' 
              ? result.error 
              : JSON.stringify(result.error);
            this.logger.error('Batch sync failed:', errorStr);
          }
        } catch (error) {
          failCount += batch.length;
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.logger.error('Batch sync error:', errorMessage);
          
          for (const item of batch) {
            await this.queue.incrementRetry(item.id, errorMessage, 'exception');
          }
        }
      }

      // Reset backoff if we had any success
      if (hasSuccess) {
        this.resetBackoff();
      }

      // Get count of items moved to dead letter
      const movedToDeadLetter = this.queue.getAndResetDeadLetterCount();

      this.logger.info(`Sync completed: ${successCount} success, ${failCount} failed, ${skippedCount} skipped, ${movedToDeadLetter} moved to dead letter`);
      
      this.emitSyncEnd(successCount, failCount, skippedCount, movedToDeadLetter);

    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger.error('Queue sync failed:', errorMessage);
      this.emitSyncEnd(0, 0, 0, 0);
      throw error;
    } finally {
      this.queue.setProcessing(false);
    }
  }

  private emitSyncEnd(success: number, failed: number, skipped: number, movedToDeadLetter: number): void {
    const duration = this.syncStartTime ? Date.now() - this.syncStartTime.getTime() : 0;
    this.config.onSyncEnd?.({ 
      success, 
      failed, 
      skipped,
      movedToDeadLetter,
      duration,
      timestamp: new Date().toISOString()
    });
    this.syncStartTime = null;
  }

  private applyBackoff(): void {
    // Apply jitter (10%)
    const jitter = 0.9 + Math.random() * 0.2;
    this.backoffMultiplier = Math.min(this.backoffMultiplier * 2, 8);
    
    const newInterval = Math.round(this.baseInterval * this.backoffMultiplier * jitter);
    this.logger.debug(`Backoff applied: multiplier=${this.backoffMultiplier}, interval=${newInterval}ms`);
    
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
      this.startAutoSync(newInterval);
    }
  }

  private resetBackoff(): void {
    if (this.backoffMultiplier > 1) {
      this.backoffMultiplier = 1;
      this.logger.debug('Backoff reset, restoring original interval');
      
      if (this.syncInterval) {
        clearInterval(this.syncInterval);
        this.startAutoSync(this.baseInterval);
      }
    }
  }

  public async getStats(userId?: string, useCache: boolean = true): Promise<UserStats> {
    this.checkInitialization();
    return this.statsAPI.getUserStats(userId, useCache);
  }

  public async getPartnerStats(useCache: boolean = true): Promise<PartnerStats> {
    this.checkInitialization();
    return this.statsAPI.getPartnerStats(useCache);
  }

  public async getQueueStatus(): Promise<{
    size: number;
    pending: number;
    inProgress: number;
    deadLetter: number;
    bytes: number;
    analytics: {
      totalAdded: number;
      totalProcessed: number;
      totalFailed: number;
      totalDropped: number;
      averageRetries: number;
    };
  }> {
    this.checkInitialization();
    return this.queue.getStatus();
  }

  public async getDeadLetterQueue(): Promise<QueueItem[]> {
    this.checkInitialization();
    return this.queue.getDeadLetterItems();
  }

  public async clearDeadLetterQueue(): Promise<void> {
    this.checkInitialization();
    await this.queue.clearDeadLetter();
    this.logger.info('Dead letter queue cleared');
  }

  public async retryDeadLetterItems(itemIds?: string[]): Promise<void> {
    this.checkInitialization();
    
    const deadLetterItems = await this.queue.getDeadLetterItems();
    const itemsToRetry = itemIds 
      ? deadLetterItems.filter(item => itemIds.includes(item.id))
      : deadLetterItems;
    
    for (const item of itemsToRetry) {
      // Reset retry count and re-add to queue
      item.retryCount = 0;
      item.errorHistory = [];
      await this.queue.add(item);
    }
    
    // Clear retried items from dead letter
    const idsToRemove = itemsToRetry.map(item => item.id);
    for (const id of idsToRemove) {
      await this.storage.remove(`deadletter:${id}`);
    }
    
    this.logger.info(`Retried ${itemsToRetry.length} items from dead letter queue`);
  }

  public async getUserSettings(userId: string): Promise<UserSettings> {
    this.checkInitialization();
    
    const SETTINGS_KEY = `settings:${userId}`;
    const stored = await this.storage.get<UserSettings>(SETTINGS_KEY);
    
    if (stored) {
      return stored;
    }
    
    // Default settings
    return {
      enabled: true,
      syncInterval: 'hourly',
      reviewFrequency: 'normal',
      categories: [],
      difficulty: 'adaptive',
      notifications: true,
      soundEffects: true,
      language: 'en',
      timezone: Intl.DateTimeFormat().resolvedOptions().timeZone
    };
  }

  public async updateSettings(userId: string, settings: Partial<UserSettings>): Promise<void> {
    this.checkInitialization();
    
    const current = await this.getUserSettings(userId);
    const updated = { ...current, ...settings };
    
    const SETTINGS_KEY = `settings:${userId}`;
    await this.storage.set(SETTINGS_KEY, updated);
    
    this.logger.info('Settings updated', { userId });
  }

  public async checkConnection(): Promise<boolean> {
    try {
      const health = await this.wrongAnswerAPI.healthCheck();
      return health.status === 'healthy' || health.status === 'degraded';
    } catch {
      return false;
    }
  }

  public async getHealthStatus(): Promise<HealthCheckResponse> {
    this.checkInitialization();
    return this.wrongAnswerAPI.healthCheck();
  }

  public getRecentLogs(): Array<{ level: LogLevel; message: string; timestamp: Date }> {
    return this.logger.getRecentLogs();
  }

  public async exportQueueData(): Promise<{
    queue: QueueItem[];
    deadLetter: QueueItem[];
    settings: Record<string, UserSettings>;
    stats: any;
  }> {
    this.checkInitialization();
    
    const queue = await this.queue.getAll();
    const deadLetter = await this.queue.getDeadLetterItems();
    const keys = await this.storage.getAllKeys();
    const settings: Record<string, UserSettings> = {};
    
    for (const key of keys) {
      if (key.startsWith('settings:')) {
        const userId = key.replace('settings:', '');
        const userSettings = await this.storage.get<UserSettings>(key);
        if (userSettings) {
          settings[userId] = userSettings;
        }
      }
    }
    
    return {
      queue,
      deadLetter,
      settings,
      stats: this.queue.getAnalytics()
    };
  }

  public async importQueueData(data: {
    queue?: QueueItem[];
    settings?: Record<string, UserSettings>;
  }): Promise<void> {
    this.checkInitialization();
    
    if (data.queue) {
      for (const item of data.queue) {
        await this.queue.add(item);
      }
      this.logger.info(`Imported ${data.queue.length} queue items`);
    }
    
    if (data.settings) {
      for (const [userId, settings] of Object.entries(data.settings)) {
        await this.updateSettings(userId, settings);
      }
      this.logger.info(`Imported settings for ${Object.keys(data.settings).length} users`);
    }
  }

  private startAutoSync(interval: number): void {
    if (this.syncInterval) {
      clearInterval(this.syncInterval);
    }

    this.syncInterval = setInterval(async () => {
      try {
        await this.syncQueue();
      } catch (error) {
        const errorMessage = error instanceof Error ? error.message : String(error);
        this.logger.error('Auto sync failed:', errorMessage);
      }
    }, interval);

    this.logger.info(`Auto sync started with interval: ${interval}ms`);
  }

  private validateConfig(config: ConfigOptions): void {
    if (!config.partnerId) {
      throw new Error('partnerId is required');
    }
    if (!config.apiKey) {
      throw new Error('apiKey is required');
    }
    if (config.syncInterval && config.syncInterval < 10000) {
      throw new Error('syncInterval must be at least 10000ms (10 seconds)');
    }
    if (config.batchSize && (config.batchSize < 1 || config.batchSize > 100)) {
      throw new Error('batchSize must be between 1 and 100');
    }
    if (config.maxRetries && (config.maxRetries < 1 || config.maxRetries > 10)) {
      throw new Error('maxRetries must be between 1 and 10');
    }
    if (config.timeout && (config.timeout < 1000 || config.timeout > 60000)) {
      throw new Error('timeout must be between 1000ms and 60000ms');
    }
    if (config.maxQueueSize && config.maxQueueSize < 10) {
      throw new Error('maxQueueSize must be at least 10');
    }
    if (config.maxQueueBytes && config.maxQueueBytes < 1024) {
      throw new Error('maxQueueBytes must be at least 1024 bytes');
    }
  }

  private validateWrongAnswer(wrongAnswer: WrongAnswer): void {
    if (!wrongAnswer.question || wrongAnswer.question.trim() === '') {
      throw new Error('question is required and cannot be empty');
    }
    if (!wrongAnswer.correctAnswer || wrongAnswer.correctAnswer.trim() === '') {
      throw new Error('correctAnswer is required and cannot be empty');
    }
    if (!wrongAnswer.userAnswer || wrongAnswer.userAnswer.trim() === '') {
      throw new Error('userAnswer is required and cannot be empty');
    }
    if (wrongAnswer.difficulty && !['easy', 'medium', 'hard'].includes(wrongAnswer.difficulty)) {
      throw new Error('difficulty must be easy, medium, or hard');
    }
    if (wrongAnswer.options && !Array.isArray(wrongAnswer.options)) {
      throw new Error('options must be an array');
    }
    if (wrongAnswer.tags && !Array.isArray(wrongAnswer.tags)) {
      throw new Error('tags must be an array');
    }
  }

  private checkInitialization(): void {
    if (!this.isInitialized) {
      throw new Error('SDK not initialized. Call initialize() first.');
    }
  }

  public async destroy(): Promise<void> {
    try {
      if (this.syncInterval) {
        clearInterval(this.syncInterval);
        this.syncInterval = null;
      }

      // Final sync if authenticated
      if (this.auth?.isAuthenticated()) {
        await this.syncQueue().catch(error => {
          const errorMessage = error instanceof Error ? error.message : String(error);
          this.logger?.warn('Final sync failed during destroy:', errorMessage);
        });
      }

      // Export data before clearing (optional backup)
      const backup = await this.exportQueueData();
      const BACKUP_KEY = `backup:${Date.now()}`;
      await this.storage.set(BACKUP_KEY, backup);

      await this.storage?.clear();
      await this.auth?.logout();

      this.isInitialized = false;
      this.logger?.info('SDK destroyed successfully');
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.logger?.error('Error during SDK destroy:', errorMessage);
      throw error;
    }
  }
}

// ======================
// 12. React Hooks with Enhanced Features (src/components/react/hooks/useLockLearn.ts)
// ======================

import { useState, useEffect, useCallback, useRef } from 'react';
import type { 
  ConfigOptions,
  WrongAnswer,
  UserStats,
  PartnerStats,
  QueueItem,
  UserProfile,
  HealthCheckResponse
} from '../../../types';
import { LockLearnClient } from '../../../core/LockLearnClient';

type TimerType = ReturnType<typeof setTimeout>;

interface UseLockLearnOptions {
  config?: ConfigOptions;
  autoInit?: boolean;
  client?: LockLearnClient;
  healthCheckInterval?: number;
}

interface UseLockLearnReturn {
  client: LockLearnClient;
  isInitialized: boolean;
  isConnected: boolean;
  isLoading: boolean;
  error: Error | null;
  stats: UserStats | null;
  partnerStats: PartnerStats | null;
  queueStatus: any | null;
  healthStatus: HealthCheckResponse | null;
  userProfile: UserProfile | null;
  initialize: (config: ConfigOptions) => Promise<void>;
  authenticateUser: (userId: string, userToken?: string) => Promise<UserProfile>;
  addWrongAnswer: (wrongAnswer: WrongAnswer) => Promise<void>;
  syncNow: () => Promise<void>;
  refreshStats: () => Promise<void>;
  getDeadLetterQueue: () => Promise<QueueItem[]>;
  retryDeadLetterItems: (itemIds?: string[]) => Promise<void>;
  clearError: () => void;
}

export function useLockLearn(options: UseLockLearnOptions = {}): UseLockLearnReturn {
  // Use provided client or singleton
  const clientRef = useRef<LockLearnClient>(
    options.client || LockLearnClient.getInstance()
  );
  
  const [isInitialized, setIsInitialized] = useState(false);
  const [isConnected, setIsConnected] = useState(false);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);
  const [stats, setStats] = useState<UserStats | null>(null);
  const [partnerStats, setPartnerStats] = useState<PartnerStats | null>(null);
  const [queueStatus, setQueueStatus] = useState<any | null>(null);
  const [healthStatus, setHealthStatus] = useState<HealthCheckResponse | null>(null);
  const [userProfile, setUserProfile] = useState<UserProfile | null>(null);
  
  const connectionCheckInterval = useRef<TimerType | null>(null);
  const healthCheckInterval = useRef<TimerType | null>(null);
  const initializeCalledRef = useRef(false);

  const initialize = useCallback(async (config: ConfigOptions) => {
    // Prevent duplicate initialization
    if (initializeCalledRef.current || isInitialized) {
      return;
    }
    
    initializeCalledRef.current = true;
    
    try {
      setIsLoading(true);
      setError(null);
      await clientRef.current.initialize(config);
      setIsInitialized(true);
      
      // Initial status checks
      const health = await clientRef.current.getHealthStatus();
      setHealthStatus(health);
      setIsConnected(health.status !== 'unhealthy');
      
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      initializeCalledRef.current = false;
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [isInitialized]);

  const authenticateUser = useCallback(async (userId: string, userToken?: string): Promise<UserProfile> => {
    if (!isInitialized) {
      throw new Error('SDK not initialized');
    }

    setIsLoading(true);
    setError(null);
    
    try {
      const profile = await clientRef.current.authenticateUser(userId, userToken);
      setUserProfile(profile);
      
      // Refresh stats after authentication
      const userStats = await clientRef.current.getStats();
      setStats(userStats);
      
      return profile;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [isInitialized]);

  const addWrongAnswer = useCallback(async (wrongAnswer: WrongAnswer) => {
    if (!isInitialized) {
      throw new Error('SDK not initialized');
    }

    setIsLoading(true);
    setError(null);
    
    try {
      await clientRef.current.addWrongAnswer(wrongAnswer);
      
      // Update queue status
      const status = await clientRef.current.getQueueStatus();
      setQueueStatus(status);
      
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [isInitialized]);

  const syncNow = useCallback(async () => {
    if (!isInitialized) {
      const error = new Error('SDK not initialized. Please login first.');
      setError(error);
      return;
    }

    setIsLoading(true);
    setError(null);
    
    try {
      await clientRef.current.syncQueue();
      
      // Refresh all status after sync
      const [newStats, newPartnerStats, newQueueStatus] = await Promise.all([
        clientRef.current.getStats(),
        clientRef.current.getPartnerStats(),
        clientRef.current.getQueueStatus()
      ]);
      
      setStats(newStats);
      setPartnerStats(newPartnerStats);
      setQueueStatus(newQueueStatus);
      
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
    } finally {
      setIsLoading(false);
    }
  }, [isInitialized]);

  const refreshStats = useCallback(async () => {
    if (!isInitialized) return;
    
    try {
      const [newStats, newPartnerStats, newQueueStatus] = await Promise.all([
        clientRef.current.getStats(undefined, false), // Force refresh
        clientRef.current.getPartnerStats(false),
        clientRef.current.getQueueStatus()
      ]);
      
      setStats(newStats);
      setPartnerStats(newPartnerStats);
      setQueueStatus(newQueueStatus);
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
    }
  }, [isInitialized]);

  const getDeadLetterQueue = useCallback(async (): Promise<QueueItem[]> => {
    if (!isInitialized) {
      throw new Error('SDK not initialized');
    }
    
    return clientRef.current.getDeadLetterQueue();
  }, [isInitialized]);

  const retryDeadLetterItems = useCallback(async (itemIds?: string[]) => {
    if (!isInitialized) {
      throw new Error('SDK not initialized');
    }
    
    setIsLoading(true);
    setError(null);
    
    try {
      await clientRef.current.retryDeadLetterItems(itemIds);
      
      // Update queue status
      const status = await clientRef.current.getQueueStatus();
      setQueueStatus(status);
      
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      throw error;
    } finally {
      setIsLoading(false);
    }
  }, [isInitialized]);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  // Auto-initialization
  useEffect(() => {
    if (options.autoInit && options.config && !initializeCalledRef.current) {
      initialize(options.config).catch(console.error);
    }
  }, [options.autoInit, options.config, initialize]);

  // Connection monitoring
  useEffect(() => {
    if (!isInitialized) return;

    const checkConnection = async () => {
      try {
        const connected = await clientRef.current.checkConnection();
        setIsConnected(connected);
      } catch {
        setIsConnected(false);
      }
    };

    checkConnection();
    connectionCheckInterval.current = setInterval(checkConnection, 30000);

    return () => {
      if (connectionCheckInterval.current) {
        clearInterval(connectionCheckInterval.current);
      }
    };
  }, [isInitialized]);

  // Health monitoring
  useEffect(() => {
    if (!isInitialized) return;

    const checkHealth = async () => {
      try {
        const health = await clientRef.current.getHealthStatus();
        setHealthStatus(health);
      } catch {
        setHealthStatus({
          status: 'unhealthy',
          version: 'unknown',
          timestamp: new Date().toISOString()
        });
      }
    };

    const interval = options.healthCheckInterval || 60000;
    healthCheckInterval.current = setInterval(checkHealth, interval);

    return () => {
      if (healthCheckInterval.current) {
        clearInterval(healthCheckInterval.current);
      }
    };
  }, [isInitialized, options.healthCheckInterval]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      if (connectionCheckInterval.current) {
        clearInterval(connectionCheckInterval.current);
      }
      if (healthCheckInterval.current) {
        clearInterval(healthCheckInterval.current);
      }
    };
  }, []);

  return {
    client: clientRef.current,
    isInitialized,
    isConnected,
    isLoading,
    error,
    stats,
    partnerStats,
    queueStatus,
    healthStatus,
    userProfile,
    initialize,
    authenticateUser,
    addWrongAnswer,
    syncNow,
    refreshStats,
    getDeadLetterQueue,
    retryDeadLetterItems,
    clearError
  };
}

// ======================
// 13. Main Export (src/index.ts)
// ======================

const LockLearn = LockLearnClient.getInstance();

export default LockLearn;

export {
  LockLearnClient,
  Storage,
  Queue,
  Authentication,
  Logger,
  LogLevel,
  WrongAnswerAPI,
  StatsAPI,
  useLockLearn,
  generateUUID,
  fetchWithTimeout,
  isOnline,
  toSearchParams,
  parseSearchParams,
  getAdjustedTime,
  getServerTimeOffset
};

export type {
  ConfigOptions,
  WrongAnswer,
  QueueItem,
  UserProfile,
  UserSettings,
  UserStats,
  SubscriptionInfo,
  BatchResponse,
  PartnerStats,
  SyncResult,
  SyncProgress,
  WrongAnswerSendResponse,
  WrongAnswerGetResponse,
  ErrorDetail,
  HealthCheckResponse
};